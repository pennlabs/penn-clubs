# Generated by Django 5.1.7 on 2025-04-03 16:09

import logging  # Add logging import
import django.db.models.deletion
from django.db import migrations, models

# Get an instance of a logger
logger = logging.getLogger(__name__)

# --- Define Migration Functions ---


# Forward function to create EventShowings from Events
def populate_event_showings(apps, schema_editor):
    Event = apps.get_model("clubs", "Event")
    EventShowing = apps.get_model("clubs", "EventShowing")
    db_alias = schema_editor.connection.alias
    showings_to_create = []
    logger.info("Starting migration: populate_event_showings")
    count = 0
    total_events = Event.objects.using(db_alias).count()
    logger.info(f"Found {total_events} events to process.")

    # Process in batches using iterator to conserve memory
    for event in Event.objects.using(db_alias).iterator(chunk_size=500):
        # Use getattr for fields that might not exist on older Event states
        # or might have been removed/altered in prior migrations in the same app
        start_time = getattr(event, "start_time", None)
        end_time = getattr(event, "end_time", None)

        if start_time and end_time:
            # Provide defaults matching the new EventShowing model fields
            # Ensure location doesn't exceed max_length
            location = getattr(event, "location", None)
            if location and len(location) > 255:
                location = location[:255]
                logger.warning(f"Truncated location for Event {event.pk}")

            # Ensure non-None default for ticket_order_limit if attribute exists
            ticket_order_limit = getattr(event, "ticket_order_limit", 10)
            if ticket_order_limit is None:
                ticket_order_limit = 10

            ticket_drop_time = getattr(event, "ticket_drop_time", None)

            showings_to_create.append(
                EventShowing(
                    event_id=event.pk,
                    start_time=start_time,
                    end_time=end_time,
                    location=location,
                    ticket_order_limit=ticket_order_limit,
                    ticket_drop_time=ticket_drop_time,
                )
            )
            count += 1
        else:
            # Log events skipped due to missing time information
            logger.warning(
                f"Skipping Event {event.pk}: missing start_time or end_time."
            )

        # Bulk create in batches to manage memory
        if len(showings_to_create) >= 500:
            try:
                EventShowing.objects.using(db_alias).bulk_create(showings_to_create)
                logger.info(f"Created batch of {len(showings_to_create)} showings.")
            except Exception as e:
                logger.error(f"Error bulk creating showings: {e}")
                # Depending on the error, might need to stop or handle differently
                raise  # Re-raise error to halt migration on failure
            showings_to_create = []

    # Create any remaining showings
    if showings_to_create:
        try:
            EventShowing.objects.using(db_alias).bulk_create(showings_to_create)
            logger.info(f"Created final batch of {len(showings_to_create)} showings.")
        except Exception as e:
            logger.error(f"Error bulk creating final batch of showings: {e}")
            raise  # Re-raise error

    logger.info(f"Finished creating showings for {count} out of {total_events} events.")


# Backward function for populate_event_showings
def remove_event_showings(apps, schema_editor):
    EventShowing = apps.get_model("clubs", "EventShowing")
    db_alias = schema_editor.connection.alias
    logger.info("Starting reverse migration: remove_event_showings")
    try:
        deleted_count, _ = EventShowing.objects.using(db_alias).all().delete()
        logger.info(f"Deleted {deleted_count} EventShowing objects.")
    except Exception as e:
        logger.error(f"Error deleting EventShowing objects: {e}")
        # Allow reversal to continue if possible, but log the error


# Forward function to update Ticket FKs
def update_ticket_foreign_keys(apps, schema_editor):
    Ticket = apps.get_model("clubs", "Ticket")
    EventShowing = apps.get_model("clubs", "EventShowing")
    db_alias = schema_editor.connection.alias
    logger.info("Starting migration: update_ticket_foreign_keys")
    updated_count = 0
    skipped_count = 0
    total_tickets = (
        Ticket.objects.using(db_alias).filter(event_id__isnull=False).count()
    )
    logger.info(f"Found {total_tickets} tickets with associated events to process.")

    # Build map efficiently
    event_to_showing_map = {
        showing["event_id"]: showing["id"]
        for showing in EventShowing.objects.using(db_alias).values("id", "event_id")
    }
    logger.info(f"Built map for {len(event_to_showing_map)} events to showings.")

    tickets_to_update = []
    # Use values and iterator for memory efficiency
    ticket_iterator = (
        Ticket.objects.using(db_alias)
        .filter(event_id__isnull=False)
        .values("pk", "event_id")
        .iterator(chunk_size=500)
    )
    for ticket_data in ticket_iterator:
        ticket_pk = ticket_data["pk"]
        event_id = ticket_data["event_id"]
        showing_id = event_to_showing_map.get(event_id)

        try:
            # Fetch only the required instance for update
            ticket = Ticket(pk=ticket_pk)  # Create dummy instance for update
            if showing_id:
                ticket.showing_id = showing_id
                updated_count += 1
            else:
                logger.warning(
                    f"Ticket {ticket_pk}: Could not find EventShowing for Event "
                    f"{event_id}. Setting showing_id to NULL."
                )
                ticket.showing_id = None  # Set to null explicitly
                skipped_count += 1
            tickets_to_update.append(ticket)
        except Exception as e:  # Catch potential errors during processing
            logger.error(f"Error processing Ticket {ticket_pk}: {e}")
            continue  # Skip this ticket on error

        if len(tickets_to_update) >= 500:
            try:
                Ticket.objects.using(db_alias).bulk_update(
                    tickets_to_update, ["showing_id"]
                )
                logger.info(f"Updated batch of {len(tickets_to_update)} tickets.")
            except Exception as e:
                logger.error(f"Error bulk updating tickets: {e}")
                raise  # Halt on bulk update error
            tickets_to_update = []

    if tickets_to_update:
        try:
            Ticket.objects.using(db_alias).bulk_update(
                tickets_to_update, ["showing_id"]
            )
            logger.info(f"Updated final batch of {len(tickets_to_update)} tickets.")
        except Exception as e:
            logger.error(f"Error bulk updating final batch of tickets: {e}")
            raise  # Halt on bulk update error

    logger.info(
        f"Finished updating ticket FKs. Updated: {updated_count}, "
        f"Skipped/Null: {skipped_count}"
    )


# Backward function for update_ticket_foreign_keys
def revert_ticket_foreign_keys(apps, schema_editor):
    Ticket = apps.get_model("clubs", "Ticket")
    db_alias = schema_editor.connection.alias
    logger.info("Starting reverse migration: revert_ticket_foreign_keys")
    try:
        updated_count = Ticket.objects.using(db_alias).update(showing_id=None)
        logger.info(f"Set showing_id to NULL for {updated_count} tickets.")
    except Exception as e:
        logger.error(f"Error reverting ticket FKs: {e}")
        # Log error but allow reversal to continue


# Function for step 6: Populate temporary field in ZoomMeetingVisit
def populate_zoom_visit_temp_field(apps, schema_editor):
    ZoomMeetingVisit = apps.get_model("clubs", "ZoomMeetingVisit")
    EventShowing = apps.get_model("clubs", "EventShowing")
    db_alias = schema_editor.connection.alias
    logger.info("Starting migration: populate_zoom_visit_temp_field")

    event_to_showing_map = {
        showing["event_id"]: showing["id"]
        for showing in EventShowing.objects.using(db_alias).values("id", "event_id")
    }
    logger.info(f"Built map for {len(event_to_showing_map)} events to showings.")

    updated_count = 0
    skipped_count = 0
    visits_to_update = []

    # Use values and iterator for memory efficiency
    visit_iterator = (
        ZoomMeetingVisit.objects.using(db_alias)
        .values("pk", "event_id")
        .iterator(chunk_size=500)
    )
    for visit_data in visit_iterator:
        visit_pk = visit_data["pk"]
        old_event_id = visit_data["event_id"]

        if old_event_id is None:
            skipped_count += 1
            continue  # Skip visits with no associated event

        showing_id = event_to_showing_map.get(old_event_id)

        try:
            visit = ZoomMeetingVisit(pk=visit_pk)  # Dummy instance for update
            if showing_id:
                visit.temp_event_showing_id = showing_id
                updated_count += 1
            else:
                logger.warning(
                    f"ZoomMeetingVisit {visit_pk}: Could not find EventShowing for "
                    f"Event {old_event_id}. Setting temp_event_showing_id to NULL."
                )
                visit.temp_event_showing_id = None  # Explicitly set to None
                skipped_count += 1
            visits_to_update.append(visit)
        except Exception as e:
            logger.error(f"Error processing ZoomMeetingVisit {visit_pk}: {e}")
            skipped_count += 1
            continue

        if len(visits_to_update) >= 500:
            try:
                ZoomMeetingVisit.objects.using(db_alias).bulk_update(
                    visits_to_update, ["temp_event_showing_id"]
                )
                logger.info(
                    f"Updated batch of {len(visits_to_update)} visits (temp field)."
                )
            except Exception as e:
                logger.error(f"Error bulk updating zoom visits (temp): {e}")
                raise  # Halt on error
            visits_to_update = []

    if visits_to_update:
        try:
            ZoomMeetingVisit.objects.using(db_alias).bulk_update(
                visits_to_update, ["temp_event_showing_id"]
            )
            logger.info(
                f"Updated final batch of {len(visits_to_update)} visits (temp field)."
            )
        except Exception as e:
            logger.error(f"Error bulk updating final zoom visits (temp): {e}")
            raise  # Halt on error

    logger.info(
        f"Finished populating temp field. Updated: {updated_count}, "
        f"Skipped/Null: {skipped_count}"
    )


# Backward function for populate_zoom_visit_temp_field
def revert_zoom_visit_temp_field(apps, schema_editor):
    # No specific data action needed here for reversal of this step.
    # The temp field removal handles the schema cleanup.
    logger.info("Reverse migration: revert_zoom_visit_temp_field (no data action)")
    pass


# Function for step 8: Copy temporary field to actual 'event' FK field
def copy_zoom_visit_temp_to_event(apps, schema_editor):
    ZoomMeetingVisit = apps.get_model("clubs", "ZoomMeetingVisit")
    db_alias = schema_editor.connection.alias
    logger.info("Starting migration: copy_zoom_visit_temp_to_event")
    updated_count = 0
    visits_to_update = []

    # Iterate using only necessary fields
    visit_qs = ZoomMeetingVisit.objects.using(db_alias).filter(
        temp_event_showing_id__isnull=False
    )
    for visit in visit_qs.only("pk", "temp_event_showing_id").iterator(chunk_size=500):
        try:
            visit_update = ZoomMeetingVisit(pk=visit.pk)  # Dummy instance for update
            visit_update.event_id = visit.temp_event_showing_id
            visits_to_update.append(visit_update)
            updated_count += 1
        except Exception as e:
            logger.error(
                f"Error preparing ZoomMeetingVisit {visit.pk} for update copy: {e}"
            )
            continue  # Skip this record

        if len(visits_to_update) >= 500:
            try:
                ZoomMeetingVisit.objects.using(db_alias).bulk_update(
                    visits_to_update, ["event_id"]
                )
                logger.info(
                    f"Copied temp field to event_id for batch of "
                    f"{len(visits_to_update)} visits."
                )
            except Exception as e:
                logger.error(f"Error bulk updating zoom visit event_id from temp: {e}")
                raise  # Halt on error
            visits_to_update = []

    if visits_to_update:
        try:
            ZoomMeetingVisit.objects.using(db_alias).bulk_update(
                visits_to_update, ["event_id"]
            )
            logger.info(
                f"Copied temp field to event_id for final batch of "
                f"{len(visits_to_update)} visits."
            )
        except Exception as e:
            logger.error(
                f"Error bulk updating final zoom visit event_id from temp: {e}"
            )
            raise  # Halt on error

    logger.info(f"Finished copying temp field to event_id for {updated_count} visits.")


# Backward function for copy_zoom_visit_temp_to_event
def revert_zoom_visit_copy(apps, schema_editor):
    # This runs *before* AlterField reverses 'event' back to pointing to Event.
    # We need to map the showing PK (currently in event_id) back to the original
    # event PK.
    ZoomMeetingVisit = apps.get_model("clubs", "ZoomMeetingVisit")
    EventShowing = apps.get_model("clubs", "EventShowing")
    db_alias = schema_editor.connection.alias
    logger.info("Starting reverse migration: revert_zoom_visit_copy")

    showing_to_event_map = {
        showing["id"]: showing["event_id"]
        for showing in EventShowing.objects.using(db_alias).values("id", "event_id")
        if showing["event_id"] is not None
    }
    logger.info(f"Built map for {len(showing_to_event_map)} showings back to events.")

    updated_count = 0
    skipped_count = 0
    visits_to_update = []

    # Use values iterator
    visit_iterator = (
        ZoomMeetingVisit.objects.using(db_alias)
        .values("pk", "event_id")
        .iterator(chunk_size=500)
    )
    for visit_data in visit_iterator:
        visit_pk = visit_data["pk"]
        current_event_fk_value = visit_data["event_id"]  # This holds the showing PK

        if current_event_fk_value is None:
            skipped_count += 1
            continue

        original_event_id = showing_to_event_map.get(current_event_fk_value)

        try:
            visit = ZoomMeetingVisit(pk=visit_pk)  # Dummy instance
            if original_event_id:
                # Set event_id to the original Event PK.
                # This is okay before AlterField reverses.
                visit.event_id = original_event_id
                updated_count += 1
            else:
                logger.warning(
                    f"ZoomMeetingVisit {visit_pk}: Could not map showing "
                    f"{current_event_fk_value} back to event. Setting event_id "
                    f"to NULL for reversal."
                )
                visit.event_id = None  # Set null if mapping fails
                skipped_count += 1
            visits_to_update.append(visit)
        except Exception as e:
            logger.error(
                f"Error preparing ZoomMeetingVisit {visit_pk} for reverse copy: {e}"
            )
            skipped_count += 1
            continue

        if len(visits_to_update) >= 500:
            try:
                ZoomMeetingVisit.objects.using(db_alias).bulk_update(
                    visits_to_update, ["event_id"]
                )
                logger.info(
                    f"Reverted event_id for batch of {len(visits_to_update)} visits."
                )
            except Exception as e:
                logger.error(f"Error bulk reverting zoom visit event_id: {e}")
                # Log error but attempt to continue reversal
            visits_to_update = []

    if visits_to_update:
        try:
            ZoomMeetingVisit.objects.using(db_alias).bulk_update(
                visits_to_update, ["event_id"]
            )
            logger.info(
                f"Reverted event_id for final batch of {len(visits_to_update)} visits."
            )
        except Exception as e:
            logger.error(f"Error bulk reverting final zoom visit event_id: {e}")
            # Log error

    logger.info(
        f"Finished reverting event_id. Updated: {updated_count}, "
        f"Skipped/Null: {skipped_count}"
    )


# --- End Migration Functions ---


class Migration(migrations.Migration):

    dependencies = [
        ("clubs", "0119_registrationqueuesettings"),
    ]

    operations = [
        # 1. Create the new EventShowing model
        migrations.CreateModel(
            name="EventShowing",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("start_time", models.DateTimeField()),
                ("end_time", models.DateTimeField()),
                (
                    "location",
                    models.CharField(blank=True, max_length=255, null=True),
                ),
                ("ticket_order_limit", models.IntegerField(default=10)),
                (
                    "ticket_drop_time",
                    models.DateTimeField(blank=True, null=True),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "event",
                    models.ForeignKey(
                        # Point to the parent Event
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="showings",  # Add related_name
                        to="clubs.event",
                    ),
                ),
            ],
        ),
        # 2. Add the 'showing' ForeignKey to Ticket (nullable for now)
        migrations.AddField(
            model_name="ticket",
            name="showing",
            field=models.ForeignKey(
                blank=True,
                null=True,
                # Use SET_NULL or CASCADE as appropriate
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="tickets",
                to="clubs.eventshowing",
            ),
        ),
        # 3. Populate EventShowing from existing Event data
        # RunPython operations should ideally be atomic if state is passed between them,
        # but here they operate sequentially on the database state.
        migrations.RunPython(
            populate_event_showings, reverse_code=remove_event_showings
        ),
        # 4. Update Ticket.showing FK based on the original Ticket.event FK
        migrations.RunPython(
            update_ticket_foreign_keys, reverse_code=revert_ticket_foreign_keys
        ),
        # 5. Add temporary FK field to ZoomMeetingVisit pointing to EventShowing
        migrations.AddField(
            model_name="zoommeetingvisit",
            name="temp_event_showing",
            field=models.ForeignKey(
                null=True,
                blank=True,  # Allow blank during population step
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="+",  # No reverse relation needed for temp field
                to="clubs.eventshowing",
            ),
        ),
        # 6. Populate the temporary FK field in ZoomMeetingVisit using original event_id
        migrations.RunPython(
            populate_zoom_visit_temp_field, reverse_code=revert_zoom_visit_temp_field
        ),
        # 7. Alter ZoomMeetingVisit.event FK to point to EventShowing
        # Note: The actual FK *value* (integer) in the column remains
        # temporarily incorrect until step 8 copies the correct showing ID into it.
        migrations.AlterField(
            model_name="zoommeetingvisit",
            name="event",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="visits",
                to="clubs.eventshowing",
                # Making it nullable temporarily isn't strictly needed due to the
                # temp field workflow but doesn't hurt if the FK constraint allows
                # it during the transition.
                # null=True,
                # Temporarily allow null during transition? Might interfere.
                # Best to rely on temp field.
            ),
        ),
        # 8. Copy the correct showing ID from the temporary field to the
        #    now-repointed 'event' field
        migrations.RunPython(
            copy_zoom_visit_temp_to_event, reverse_code=revert_zoom_visit_copy
        ),

        # Make original Event fields nullable *after* data has been migrated
        migrations.AlterField(
            model_name="event",
            name="end_time",
            field=models.DateTimeField(blank=True, null=True),
        ),
        # Ensure location field exists in Event model before altering
        # (Check models.py state at time of this migration)
        migrations.AlterField(
            model_name="event",
            name="location",  # Assuming 'location' existed on Event
            field=models.CharField(blank=True, max_length=255, null=True),
        ),
        migrations.AlterField(
            model_name="event",
            name="start_time",
            field=models.DateTimeField(blank=True, null=True),
        ),
        # Assuming 'ticket_drop_time' existed on Event
        migrations.AlterField(
            model_name="event",
            name="ticket_drop_time",
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name="event",
            name="ticket_order_limit",
            field=models.IntegerField(
                blank=True, default=10, null=True
            ),  # Keep original default if applicable
        ),
        # Alter original Ticket.event FK: make nullable and potentially change
        # related_name
        # This field is now redundant as Ticket.showing holds the primary link
        migrations.AlterField(
            model_name="ticket",
            name="event",
            field=models.ForeignKey(
                blank=True,
                null=True,
                # Keep DO_NOTHING or change based on desired behavior if an Event
                # is deleted
                on_delete=django.db.models.deletion.DO_NOTHING,
                # Rename related_name to avoid conflicts if both 'event' and
                # 'showing.event' are accessed
                related_name="tickets_old_event_link",
                to="clubs.event",
            ),
        ),
    ]
